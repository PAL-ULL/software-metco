/***********************************************************************************
 * AUTHORS
 *   - Gara Miranda Valladares
 *   - Carlos Segura González
 * 
 * DATE
 *    March 2008 
 **********************************************************************************/
 
#include <cstdlib>
#include <iostream>
#include <signal.h>
#include <math.h>

#include "VarPopSizeEA.h"

// Algorithm initialization
bool VarPopSizeEA::init(const vector<string> &params){
	// Check number of parameters
	if (params.size() != 6){
		cout << "Parámetros incorrectos: softBlock hardBlock initSize maxPopSize pm pc" << endl;
		return false;
	}
	// Only mono-objective optimization is supported
	if (getSampleInd()->getNumberOfObj() != 1){
		cout << "Multi-Objective VarPopSizeEA not supported" << endl;
		return false;
	}

	// Parameters initialization
	globalBlock = 0;
	this->softBlock = atoi(params[0].c_str());
	this->hardBlock = atoi(params[1].c_str());
	this->initSize = atoi(params[2].c_str());
	this->maxPopSize = atoi(params[3].c_str());
	this->pm = atof(params[4].c_str());
	this->pc = atof(params[5].c_str());
	optD = getSampleInd()->getInternalOptDirection(0);
	setPopulationSize(initSize);
	block.insert(block.begin(), initSize + 1, 0);
	bestScoreIndividual.push_back(0);
	return true;
}

// VarPopSizeEA generation
void VarPopSizeEA::runGeneration(){
	createOffspring();
	checkOffspringImprovements();
	selection();
	checkGlobalBlock();
}

// Fill the initial population
void VarPopSizeEA::fillPopWithNewIndsAndEvaluate() {
	// The element 0 in the population is the best individual found along the execution:
	// such element is nos considered as part of the population, but it is stored in 
	// such position because we wanted to implement a migration which only accepts
	// the migrated individuals when it is the best found
	if (population->size() == 0){
		population->push_back(NULL);
	}
	for (int i = population->size(); i <= getPopulationSize(); i++) {
		Individual *newInd = getSampleInd()->internalClone();
		newInd->restart();
		internalEvaluate(newInd);
		population->push_back (newInd);
		bestScoreIndividual.push_back((*population)[population->size()-1]->getObj(0));// best in such position
	}
}

// Evaluate and save in the position 0 if it is the best individual
void VarPopSizeEA::internalEvaluate(Individual *ind){
	evaluate(ind);
	insertInArchive(ind);

	bool notInitialized = ((*population)[0] == NULL);
	if (notInitialized || isBetter(ind->getObj(0), (*population)[0]->getObj(0))){
		delete (*population)[0];
		(*population)[0] = ind->internalClone();
	}
}

// Evaluate the population
void VarPopSizeEA::evaluation(){
	for (unsigned int i = 1; i < population->size(); i++){
		internalEvaluate((*population)[i]);
	}
}

// Create offspring
// - offspring = population
// - mutation(population)
// - evaluate(population)
// - crossover and select the best between the offspring generated by crossover and the parent
void VarPopSizeEA::createOffspring(){
	offSpring.clear();
	offSpring.push_back(NULL);//element 0 in offspring not used
	for (unsigned int i = 1; i < population->size(); i++){//1 offspring for each element in population
		offSpring.push_back((*population)[i]->internalClone());
		offSpring[i]->mutation(pm);
		internalEvaluate(offSpring[i]);
	}
	crossoverVariation();
}

// Peform crossover by selecting random partners. Evaluates offspring and selects
// the best between parent and offspring.
void VarPopSizeEA::crossoverVariation(){
	// Select partners randomly. Each individual only participates in one crossover
	vector<int> indexes;
	for (unsigned int i = 1; i < offSpring.size(); i++){
		indexes.push_back(i);
	}
	while(indexes.size() > 2){
		//Parent 1
		int index1 = (int)((indexes.size()) * ((double)(rand()/(RAND_MAX + 1.0))));
		int elem1 = indexes[index1];
		indexes[index1] = indexes[indexes.size()-1];
		indexes.pop_back();	
		//Parent 2
		int index2 = (int)((indexes.size()) * ((double)(rand()/(RAND_MAX + 1.0))));
		int elem2 = indexes[index2];
		indexes[index2] = indexes[indexes.size()-1];
		indexes.pop_back();

		if ((rand()/(RAND_MAX + 1.0)) < pc ){ //perform crossover, but save the best between parents and offsprings
			Individual *ind1 = offSpring[elem1]->internalClone();
			Individual *ind2 = offSpring[elem2]->internalClone();
			offSpring[elem1]->crossover(offSpring[elem2]);

			Individual *inds[2] = {ind1, ind2};
			int elems[2] = {elem1, elem2};
			for (int i = 0; i < 2; i++){
				// Evaluate offsprings
				internalEvaluate(offSpring[elems[i]]);
				// Select best between offspring and parent
				if (isBetter(offSpring[elems[i]]->getObj(0), inds[i]->getObj(0))){
					delete inds[i];
				} else {
					delete offSpring[elems[i]];
					offSpring[elems[i]] = inds[i];
				}
			}
		}
	}
}

// Check global blocking: any of the individuals improve the best
// solution previosly located in its position
void VarPopSizeEA::checkOffspringImprovements(){
	for (unsigned int i = 1; i < population->size(); i++){
		if (isBetter(offSpring[i]->getObj(0), bestScoreIndividual[i])){
			globalBlock = 0;
			bestScoreIndividual[i] = offSpring[i]->getObj(0);
		}
	}
}

// isBetter the solution a, than the solution b
bool VarPopSizeEA::isBetter(double a, double b){
	return (optD == MINIMIZE)?(a < b):(a > b);
}

// Apply (1+1) selection operator if (block[i] < softBlock)
// or (1,1) selection operator if (block[i] == softBlock)
void VarPopSizeEA::selection(){
	for (unsigned int i = 1; i < offSpring.size(); i++){
		if (isBetter(offSpring[i]->getObj(0), (*population)[i]->getObj(0)) || (block[i] == softBlock)){
			delete (*population)[i];
			(*population)[i] = offSpring[i];
			block[i] = 0;
		} else {
			delete offSpring[i];
			block[i]++;
		} 
	}
}

// Check is the best in each position has been blocked for more than
// hardBlock generations. If so, increment the population size if
// is smaller than maxPopSize
void VarPopSizeEA::checkGlobalBlock(){
	if ((globalBlock >= hardBlock)){
		if (population->size() < maxPopSize){
			Individual *newInd = getSampleInd()->internalClone();
			newInd->restart();
			evaluate(newInd);
			insertInArchive(newInd);
			population->push_back(newInd);
			bestScoreIndividual.push_back((*population)[population->size()-1]->getObj(0));
			block.push_back(0);
		}
	}
	globalBlock++;
}

// Get the best solution (stored in population[0])
void VarPopSizeEA::getSolution(MOFront *p) {
	p->insert((*population)[0]);
}

// Print Algorithm Information
void VarPopSizeEA::printInfo(ostream &os) const {
	os << "VarPopSizeEA" << endl;
	os << "Number of Evaluations = " << getEvaluations() << endl;
	os << "softBlock = " << softBlock << endl;
	os << "hardBlock = " << hardBlock << endl;
	os << "maxPopSize = " << maxPopSize << endl;
	os << "Mutation Probability = " << pm << endl;
	os << "End Population Size = " << population->size() << endl;
}

// Save information in order to be able to restart the algorithm (parallel):
// information about blocking. If not, in the parallel version never increments 
// the population size.
//
// Recuperamos la poblacion en los individuos que hayan empeorado mas de un 0.5%
double *VarPopSizeEA::getRestartInfo(){
	double *data = new double[1 + 1 + block.size() + bestScoreIndividual.size()];
	int index = 0;
	data[index++] = population->size();
	data[index++] = globalBlock;
	for (int i = 0; i < block.size(); i++)
		data[index++] = block[i];
	for (int i = 0; i < bestScoreIndividual.size(); i++)
		data[index++] = bestScoreIndividual[i];
	return data;
}
	
// Restore blocking information (parallel version)
// Es llamado cuando va a comenzar la ejecucion
// Guardamos la poblacion actual por si hay que recuperar algun individuo
void VarPopSizeEA::setRestartInfo(double *data){
	int index = 0;
	int nInd = (int)data[index++];
	globalBlock = (int)data[index++];
	block.clear();
	for (int i = 0; i < nInd; i++){
		block.push_back((int)data[index++]);
	}
	bestScoreIndividual.clear();
	for (int i = 0; i < nInd; i++){
		bestScoreIndividual.push_back(data[index++]);
	}
}
